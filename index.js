// Interpolate values for a function of the form `f(x, y) = z` within a 1x1 square (from (x, y) = (0, 0) to (1, 1)) by providing 16 points at it's edges and around it ((-1, -1), (0, -1), (1, -1), (2, -1), (0, -1), (0, 0), ..., (3, 3)).
// Takes in the 16 values for z as a 2D array. Make sure the first selector corresponds to x position (e.g. points[x][y]). This is the transpose (flipped) of the visual layout if you declare the array in javascript manually. Also, keep in mind that values[0][0] actually corresponds to the value for (-1, -1).
// Returns a function that takes two arguments (x, y) and returns the interpolated value.
function createInterpolator(p) {
  //Coefficients: first number corresponds to x's exponent in the polynomial, the second to y's.
  const
  a00 = p[1][1],
  a01 = (-1/2)*p[1][0] + (1/2)*p[1][2],
  a02 = p[1][0] + (-5/2)*p[1][1] + 2*p[1][2] + (-1/2)*p[1][3],
  a03 = (-1/2)*p[1][0] + (3/2)*p[1][1] + (-3/2)*p[1][2] + (1/2)*p[1][3],
  a10 = (-1/2)*p[0][1] + (1/2)*p[2][1],
  a11 = (1/4)*p[0][0] + (-1/4)*p[0][2] + (-1/4)*p[2][0] + (1/4)*p[2][2],
  a12 = (-1/2)*p[0][0] + (5/4)*p[0][1] + (-1)*p[0][2] + (1/4)*p[0][3] + (1/2)*p[2][0] + (-5/4)*p[2][1] + p[2][2] + (-1/4)*p[2][3],
  a13 = (1/4)*p[0][0] + (-3/4)*p[0][1] + (3/4)*p[0][2] + (-1/4)*p[0][3] + (-1/4)*p[2][0] + (3/4)*p[2][1] + (-3/4)*p[2][2] + (1/4)*p[2][3],
  a20 = p[0][1] + (-5/2)*p[1][1] + 2*p[2][1] + (-1/2)*p[3][1],
  a21 = (-1/2)*p[0][0] + (1/2)*p[0][2] + (5/4)*p[1][0] + (-5/4)*p[1][2] + (-1)*p[2][0] + p[2][2] + (1/4)*p[3][0] + (-1/4)*p[3][2],
  a22 = p[0][0] + (-5/2)*p[0][1] + 2*p[0][2] + (-1/2)*p[0][3] + (-5/2)*p[1][0] + (25/4)*p[1][1] + (-5)*p[1][2] + (5/4)*p[1][3] + 2*p[2][0] + (-5)*p[2][1] + 4*p[2][2] + (-1)*p[2][3] + (-1/2)*p[3][0] + (5/4)*p[3][1] + (-1)*p[3][2] + (1/4)*p[3][3],
  a23 = (-1/2)*p[0][0] + (3/2)*p[0][1] + (-3/2)*p[0][2] + (1/2)*p[0][3] + (5/4)*p[1][0] + (-15/4)*p[1][1] + (15/4)*p[1][2] + (-5/4)*p[1][3] + (-1)*p[2][0] + 3*p[2][1] + (-3)*p[2][2] + p[2][3] + (1/4)*p[3][0] + (-3/4)*p[3][1] + (3/4)*p[3][2] + (-1/4)*p[3][3],
  a30 = (-1/2)*p[0][1] + (3/2)*p[1][1] + (-3/2)*p[2][1] + (1/2)*p[3][1],
  a31 = (1/4)*p[0][0] + (-1/4)*p[0][2] + (-3/4)*p[1][0] + (3/4)*p[1][2] + (3/4)*p[2][0] + (-3/4)*p[2][2] + (-1/4)*p[3][0] + (1/4)*p[3][2],
  a32 = (-1/2)*p[0][0] + (5/4)*p[0][1] + (-1)*p[0][2] + (1/4)*p[0][3] + (3/2)*p[1][0] + (-15/4)*p[1][1] + 3*p[1][2] + (-3/4)*p[1][3] + (-3/2)*p[2][0] + (15/4)*p[2][1] + (-3)*p[2][2] + (3/4)*p[2][3] + (1/2)*p[3][0] + (-5/4)*p[3][1] + p[3][2] + (-1/4)*p[3][3],
  a33 = (1/4)*p[0][0] + (-3/4)*p[0][1] + (3/4)*p[0][2] + (-1/4)*p[0][3] + (-3/4)*p[1][0] + (9/4)*p[1][1] + (-9/4)*p[1][2] + (3/4)*p[1][3] + (3/4)*p[2][0] + (-9/4)*p[2][1] + (9/4)*p[2][2] + (-3/4)*p[2][3] + (-1/4)*p[3][0] + (3/4)*p[3][1] + (-3/4)*p[3][2] + (1/4)*p[3][3];

  return (x, y) => {
    const
    x2 = x*x,
    x3 = x*x2,
    y2 = y*y,
    y3 = y*y2;

    return
    (a00 + a01*y + a02*y2 + a03*y3) +
    (a10 + a11*y + a12*y2 + a13*y3) * x +
    (a20 + a21*y + a22*y2 + a23*y3) * x2 +
    (a30 + a31*y + a32*y2 + a33*y3) * x3;
  }
}

module.exports = {
  createInterpolator: createInterpolator
};
